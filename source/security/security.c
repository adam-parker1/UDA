
// IDAM Client Server Identity Authentication
//
// Architecture models: (single/multiple tier network; mesh or bridge network)
//
// a)	client connects to a server
// b)	client connects to a proxy that connects to a server
// c)	client connects to a server that connects to a server etc. (multi-tier connection)
// d)	client connects to a proxy that connects to a server that connects to a server etc. (multi-tier connection)
//
// IDAM servers without a public key server component must use PKI (Public Key Infrastructure) X.509 based certificates.
// X.509 certificates establish the authenticity of the binding between a public key and its owner through a 
// digital signature created using the private key of a trusted third party - a Certificate Authority.
// *** libksba *** to create and parse X.509 certificates (can self sign!)
// Use linux CLI openssl to create certificates [http://www.openssl.org/]
// Authenticate the client and/or server involves checking that their certificate was signed by an acceptable authority
// (Signing means the public key was generated by an authenticated person. They need the private key to complete
// the authentication process.) 
// The certificate contains the user's public key. Use the CA public key to test the
// signature => proof the certificate is valid. Servers only need the CA public keys to assist in authentication. 
//
// Web based access requires HTTPS - based on Transport Layer Security (TLS) 
// [http://en.wikipedia.org/wiki/Transport_Layer_Security] and X.509 (SSL) certificates for public keys.
// *** http://www.gnutls.org/ *** 
//
// Options:
//
// a) Mutual athentication for 2 claims of identity (the server may choose not to authenticate)
// b) Proxy does not authenticate and passes through the claim of identity to the next server as a). 
// c) Option:
//	1) The User has one identity. Intermediate servers don't authenticate with each other or the client and 
//         pass through the claim of identity to the final server. Authentication occurs between the final server 
//         and the user. 
//	2) The User has one identity. Intermediate servers authenticate with each other but don't authenticate 
//         with the client. They pass through the claim of identity to the final server. Authentication occurs 
//         between the final server and the user.
//	3) The User has one identity. All servers authenticate with the client.  **** Not adopted ****
//	4) The User has two identities. The first server authenticates with the first user identity.
//         Intermediate servers don't authenticate with each other or the client and 
//         pass through the claim of identity to the final server. Authentication occurs between the final server 
//         and the user (second identity).  
//	5) The User has two identities. The first server authenticates with the first user identity. 
//         Intermediate servers authenticate with each other but don't authenticate with the client. They
//         pass through the second claim of identity to the final server. Authentication occurs between the final server 
//         and the user (second identity).
//	6) The User has n identities. Each of n servers authenticates with the n user identities. **** Not adopted ****
// d) Proxy does not authenticate and passes through the claims of identity to the multiple servers as c).
// 
// Steps:
//
// 1> 	Client issues a token (A), encrypts with the server's public key (->EASP), passes to server (with X.509)
//	Server's public key could be obtained from a X.509 certificate (authenticated using signature and CA public key)
// 2>	Server decrypts the passed cipher (EASP) with the server's private key (->A) 
// 3>	Server encrypts the client token (A) with the client's public key (->EACP)
//	Public key could be obtained from a X.509 certificate (authenticated using signature and CA public key)
//	Public key could alternatively be obtained a user database.
// 4>	Server issues a new token (B) also encrypted with the client's public key (->EBCP), passes 
//	both to client. 
// 5>	Client decrypts the passed ciphers (EACP, EBCP) with the client's private key (->A, ->B) and 
//	checks token (A) => server authenticated (in addition to the X.509 certificate signature check)
// 6>	Client encrypts passed token (B) with the server's public key (->EBSP), passes to server
// 7>	Server decrypts the passed cipher (EBSP) with the server's private key (->B) and checks 
//	token (B) => client authenticated (in addition to the X.509 certificate signature check).
//
// 8>   Server issues a new token (B) encrypted with the client's public key (->EBCP), passes to client.
//
// All further communication between client and server are based on steps 7, 8 to ensure continuation of
// authorised data access. (X.509 certificate signature check now unneccesary)
//
// 1> Client data access request includes the encrypted token (B)
// 2> Server data (unencrypted) returned with new encrypted token + encrypted data checksum 
//
// Authentication cost is 3 RTT, incurred before the first data request is processed by the server.
//
// Authentication is completed during the first data request. No additional security based TCP/IP exchanges 
// are required thereafter.
//
// Server closedown should be avoided to maintain state. 
//
// **** The server could issue a session ID in case of lost connections to speed up access. This ID could
// have a short lifetime ~ 1 mins, sufficient to re-establish the connection at no extra cost. 
// The last issued ID could serve as both the session ID and the authentication token. 
//
//--------------------------------------------------------------------------------------------------------------------
#include "security.h"

#include <zconf.h>
#include <errno.h>

#include <clientserver/errorLog.h>
#include <logging/logging.h>
#include <clientserver/udaTypes.h>
#include <clientserver/stringUtils.h>

#define digitp(p)   (*(p) >= '0' && *(p) <= '9')
#define xfree(a)  ksba_free (a)

/**
 * Import a Security Document from a private file (a key or X.509 certificate)
 * @param file
 * @param contents
 * @param length
 * @return
 */
int importSecurityDoc(const char* file, unsigned char** contents, unsigned short* length)
{
    int err = 0;

    *length = 0;
    *contents = (unsigned char*)malloc(UDA_MAXKEY * sizeof(unsigned char));

    FILE* fd = NULL;

    errno = 0;

    if (((fd = fopen(file, "rb")) == NULL || ferror(fd) || errno != 0)) {
        if (fd != NULL) {
            fclose(fd);
        }
        THROW_ERROR(999, "Cannot open the security document: key or certificate");
    }

    size_t fileLength = fread(*contents, sizeof(char), UDA_MAXKEY, fd);

    if (!feof(fd) || fileLength == UDA_MAXKEY) {
        free(*contents);
        fclose(fd);
        THROW_ERROR(999, "Security document length limit hit!");
    }

    *length = (unsigned short)fileLength;

    fclose(fd);
    return err;
}

int makeX509CertObject(unsigned char* doc, unsigned short docLength, ksba_cert_t* cert)
{
    int err = 0;
    ksba_cert_t certificate;

    if (ksba_cert_new(&certificate) != 0) {
        THROW_ERROR(999, "Problem creating the certificate object!");
    }

    if (ksba_cert_init_from_mem(certificate, (const void*)doc, (size_t)docLength) != 0) {
        THROW_ERROR(999, "Problem initialising the certificate object!");
    }

    *cert = certificate;

    return err;
}

/**
 * Extract a Public Key from a X509 certificate file and return an S-Expression
 * @param cert
 * @param key_sexp
 * @return
 */
int extractX509SExpKey(ksba_cert_t cert, gcry_sexp_t* key_sexp)
{
    int err = 0;

    ksba_sexp_t p;
    size_t n;

    if ((p = ksba_cert_get_public_key(cert)) == NULL) {
        THROW_ERROR(999, "Failure to get the Public key!");
    }

// Get the length of the canonical S-Expression (public key)

    if ((n = gcry_sexp_canon_len(p, 0, NULL, NULL)) == 0) {
        ksba_free(p);
        THROW_ERROR(999, "did not return a proper S-Exp!");
    }

// Create an internal S-Expression from the external representation

    if (gcry_sexp_sscan(key_sexp, NULL, (char*)p, n) != 0) {
        ksba_free(p);
        THROW_ERROR(999, "S-Exp creation failed!");
    }

    ksba_free(p);

    return err;
}

/**
 * Return the public key algorithm id from the S-expression PKEY.
 *
 * FIXME: libgcrypt should provide such a function. Note that this implementation uses the names as used by libksba.
 * @param pkey
 * @return
 */
static int pk_algo_from_sexp(gcry_sexp_t pkey)
{
    gcry_sexp_t l1, l2;
    const char* name;
    size_t n;
    int algo;

    l1 = gcry_sexp_find_token(pkey, "public-key", 0);
    if (!l1) {
        return 0;
    } /* Not found.  */
    l2 = gcry_sexp_cadr(l1);
    gcry_sexp_release(l1);

    name = gcry_sexp_nth_data(l2, 0, &n);
    if (!name) {
        algo = 0; /* Not found. */
    } else if (n == 3 && !memcmp(name, "rsa", 3)) {
        algo = GCRY_PK_RSA;
    } else if (n == 3 && !memcmp(name, "dsa", 3)) {
        algo = GCRY_PK_DSA;
        /* Because this function is called only for verification we can
           assume that ECC actually means ECDSA.  */
    } else if (n == 3 && !memcmp(name, "ecc", 3)) {
        algo = GCRY_PK_ECDSA;
    } else if (n == 13 && !memcmp(name, "ambiguous-rsa", 13)) {
        algo = GCRY_PK_RSA;
    } else {
        algo = 0;
    }
    gcry_sexp_release(l2);
    return algo;
}

/* Return the number of bits of the Q parameter from the DSA key
   KEY.  */
static unsigned int get_dsa_qbits(gcry_sexp_t key)
{
    gcry_sexp_t l1, l2;
    gcry_mpi_t q;
    unsigned int nbits;

    l1 = gcry_sexp_find_token(key, "public-key", 0);
    if (!l1) {
        return 0;
    } /* Does not contain a key object.  */
    l2 = gcry_sexp_cadr(l1);
    gcry_sexp_release(l1);
    l1 = gcry_sexp_find_token(l2, "q", 1);
    gcry_sexp_release(l2);
    if (!l1) {
        return 0;
    } /* Invalid object.  */
    q = gcry_sexp_nth_mpi(l1, 1, GCRYMPI_FMT_USG);
    gcry_sexp_release(l1);
    if (!q)
        return 0; /* Missing value.  */
    nbits = gcry_mpi_get_nbits(q);
    gcry_mpi_release(q);

    return nbits;
}

static int do_encode_md(gcry_md_hd_t md, int algo, int pkalgo, unsigned int nbits, gcry_sexp_t pkey, gcry_mpi_t* r_val)
{
    int n;
    size_t nframe;
    unsigned char* frame;

    if (pkalgo == GCRY_PK_DSA || pkalgo == GCRY_PK_ECDSA) {
        unsigned int qbits;

        if (pkalgo == GCRY_PK_ECDSA) {
            qbits = gcry_pk_get_nbits(pkey);
        } else {
            qbits = get_dsa_qbits(pkey);
        }

        if ((qbits % 8)) {
            return 999;
        }

        /* Don't allow any Q smaller than 160 bits.  We don't want
       someone to issue signatures from a key with a 16-bit Q or
       something like that, which would look correct but allow
       trivial forgeries.  Yes, I know this rules out using MD5 with
       DSA. ;) */
        if (qbits < 160) {
            return 999;
        }

        /* Check if we're too short.  Too long is safe as we'll
       automatically left-truncate. */
        nframe = gcry_md_get_algo_dlen(algo);
        if (nframe < qbits / 8) {
            return 999;
            /* FIXME: we need to check the requirements for ECDSA.  */
            if (nframe < 20 || pkalgo == GCRY_PK_DSA) {
                return 999;
            }
        }

        frame = (unsigned char*)xtrymalloc(nframe);
        if (!frame) {
            return 999;
        }

        memcpy (frame, gcry_md_read(md, algo), nframe);
        n = nframe;
        /* Truncate.  */
        if (n > qbits / 8) {
            n = qbits / 8;
        }
    } else {
        int i;
        unsigned char asn[100];
        size_t asnlen;
        size_t len;

        nframe = (nbits + 7) / 8;

        asnlen = DIM(asn);
        if (!algo || gcry_md_test_algo(algo)) {
            return 999;
        }
        if (gcry_md_algo_info(algo, GCRYCTL_GET_ASNOID, asn, &asnlen)) {
            return 999;
        }

        len = gcry_md_get_algo_dlen(algo);

        if (len + asnlen + 4 > nframe) {
            return 999;
        }

        /* We encode the MD in this way:
         *
         *	   0  A PAD(n bytes)   0  ASN(asnlen bytes)  MD(len bytes)
         *
         * PAD consists of FF bytes.
         */
        frame = (unsigned char*)xtrymalloc(nframe);
        if (!frame) {
            return 999;
        }

        n = 0;
        frame[n++] = 0;
        frame[n++] = 1; /* block type */
        i = nframe - len - asnlen - 3;

        if (!((i > 1))) {
            return 999;
        }
        memset (frame + n, 0xff, i);
        n += i;
        frame[n++] = 0;
        memcpy (frame + n, asn, asnlen);
        n += asnlen;
        memcpy (frame + n, gcry_md_read(md, algo), len);
        n += len;

        if (!((n == nframe))) {
            return 999;
        }
    }

    gcry_mpi_scan(r_val, GCRYMPI_FMT_USG, frame, n, &nframe);
    xfree (frame);
    return 0;
}

int importX509Reader(const char* fileName, ksba_cert_t* cert)
{
    int err = 0;
    FILE* fp;
    ksba_reader_t r;

    errno = 0;

    fp = fopen(fileName, "rb");
    if (!fp) {
        addIdamError(&idamerrorstack, CODEERRORTYPE, __func__, 999, "Problem opening the certificate file");
        THROW_ERROR(999, strerror(errno));
    }

    err = ksba_reader_new(&r);
    if (err) {
        THROW_ERROR(999, "can't create certificate reader");
    }

    err = ksba_reader_set_file(r, fp);
    if (err) {
        THROW_ERROR(999, "can't set file reader");
    }

    err = ksba_cert_new(cert);
    if (err) {
        THROW_ERROR(999, "Problem creating a new certificate object!");
    }

    err = ksba_cert_read_der(*cert, r);
    if (err) {
        THROW_ERROR(999, "Problem initialising the certificate object!");
    }

    fclose(fp);

    return err;
}

/**
 * Test the X509 certificate dates are valid
 * @param certificate
 * @return
 */
int testX509Dates(ksba_cert_t certificate)
{
    int err = 0;
    ksba_isotime_t startDateTime = {};
    ksba_isotime_t endDateTime = {};        // ISO format referenced from UTC

    ksba_cert_get_validity(certificate, 0, startDateTime);
    ksba_cert_get_validity(certificate, 1, endDateTime);

// Current Date and Time

    time_t calendar;                    // Simple Calendar Date & Time
    struct tm* broken;                  // Broken Down calendar Time
    static char datetime[DATELENGTH];   // The Calendar Time as a formatted String

// Calendar Time

    time(&calendar);
    broken = gmtime(&calendar);
    asctime_r(broken, datetime);

    convertNonPrintable2(datetime);
    TrimString(datetime);

// Year

    char work[56];
    sprintf(work, "%.4d%.2d%.2dT%.2d%.2d%.2d", broken->tm_year + 1900, broken->tm_mon + 1, broken->tm_mday,
            broken->tm_hour, broken->tm_min, broken->tm_sec);

    if ((strcmp(work, startDateTime) <= 0) || (strcmp(endDateTime, work) <= 0)) {        // dates are in ascending order
        THROW_ERROR(999, "X509 Certificate is Invalid: Time Expired!");
    }

    return err;
}

/**
 * Check the certificate signature.
 * based on GNUPG sm/certcheck.c (gpgsm_check_cert_sig)
 * @param issuer_cert
 * @param cert
 * @return
 */
int checkX509Signature(ksba_cert_t issuer_cert, ksba_cert_t cert)
{
    int err = 0;

    const char* algoid = NULL;

// Extract the digest algorithm OID used for the signature

    if ((algoid = ksba_cert_get_digest_algo(cert)) == NULL) {
        THROW_ERROR(999, "unknown digest algorithm OID");
        return err;
    }

// Map the algorithm OID to an algorithm identifier

    int algo;
    if ((algo = gcry_md_map_name(algoid)) == 0) {
        THROW_ERROR(999, "unknown digest algorithm identifier");
        return err;
    }

// Create a new digest object with the same algorithm as the certificate signature

    gcry_md_hd_t md;
    if (gcry_md_open(&md, algo, 0) != 0) {
        THROW_ERROR(999, "md_open failed!");
        return err;
    }

// Hash the certificate

    if (ksba_cert_hash(cert, 1, HASH_FNC, md) != 0) {
        gcry_md_close(md);
        THROW_ERROR(999, "cert hash failed!");
    }

// Finalise the digest calculation

    gcry_md_final(md);

// Get the certificate signature 

    ksba_sexp_t p;
    if ((p = ksba_cert_get_sig_val(cert)) == NULL) {
        gcry_md_close(md);
        THROW_ERROR(999, "Failure to get the certificate signature!");
    }

// Get the length of the canonical S-Expression (certificate signature)

    size_t n;
    if ((n = gcry_sexp_canon_len(p, 0, NULL, NULL)) == 0) {
        gcry_md_close(md);
        ksba_free(p);
        THROW_ERROR(999, "libksba did not return a proper S-Exp!");
    }

// Create an internal S-Expression from the external representation

    gcry_sexp_t s_sig;
    if (gcry_sexp_sscan(&s_sig, NULL, (char*)p, n) != 0) {
        gcry_md_close(md);
        THROW_ERROR(999, "gcry_sexp_scan failed!");
    }

    ksba_free(p);

// Get the CA Public key  

    if ((p = ksba_cert_get_public_key(issuer_cert)) == NULL) {
        gcry_md_close(md);
        THROW_ERROR(999, "Failure to get the Public key!");
    }

// Get the length of the canonical S-Expression (public key)

    if ((n = gcry_sexp_canon_len(p, 0, NULL, NULL)) == 0) {
        gcry_md_close(md);
        ksba_free(p);
        gcry_sexp_release(s_sig);
        THROW_ERROR(999, "libksba did not return a proper S-Exp!");
    }

// Create an internal S-Expression from the external representation

    gcry_sexp_t s_pkey;
    if (gcry_sexp_sscan(&s_pkey, NULL, (char*)p, n) != 0) {
        gcry_md_close(md);
        ksba_free(p);
        gcry_sexp_release(s_sig);
        THROW_ERROR(999, "gcry_sexp_scan failed!");
    }

    ksba_free(p);

    gcry_mpi_t frame;

    if (do_encode_md(md, algo, pk_algo_from_sexp(s_pkey), gcry_pk_get_nbits(s_pkey), s_pkey, &frame) != 0) {
        gcry_md_close(md);
        gcry_sexp_release(s_sig);
        gcry_sexp_release(s_pkey);
        THROW_ERROR(999, "do_encode_md failed!");
    }

// put hash into the S-Exp s_hash 

    gcry_sexp_t s_hash;
    gcry_sexp_build(&s_hash, NULL, "%m", frame);

    gcry_mpi_release(frame);

// Verify the signature, data, public key    

    if (gcry_pk_verify(s_sig, s_hash, s_pkey) != 0) {
        THROW_ERROR(999, "Signature verification failed!");
    }

    gcry_md_close(md);
    gcry_sexp_release(s_sig);
    gcry_sexp_release(s_hash);
    gcry_sexp_release(s_pkey);

    return err;
}

//========================================================================================================
// Components taken from

/* fipsdrv.c  -  A driver to help with FIPS CAVS tests.
   Copyright (C) 2008 Free Software Foundation, Inc.

   This file is part of Libgcrypt.

   Libgcrypt is free software; you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   Libgcrypt is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this program; if not, see <http://www.gnu.org/licenses/>.
*/

#define hexdigitp(a) (digitp (a)                     \
                      || (*(a) >= 'A' && *(a) <= 'F')  \
                      || (*(a) >= 'a' && *(a) <= 'f'))
#define xtoi_1(p)   (*(p) <= '9'? (*(p)- '0'): \
                     *(p) <= 'F'? (*(p)-'A'+10):(*(p)-'a'+10))
#define xtoi_2(p)   ((xtoi_1(p) * 16) + xtoi_1((p)+1))

/* ASN.1 classes.  */
enum {
    UNIVERSAL = 0,
    APPLICATION = 1,
    ASNCONTEXT = 2,
    PRIVATE = 3
};

/* ASN.1 tags.  */
enum {
    TAG_NONE = 0,
    TAG_BOOLEAN = 1,
    TAG_INTEGER = 2,
    TAG_BIT_STRING = 3,
    TAG_OCTET_STRING = 4,
    TAG_NULL = 5,
    TAG_OBJECT_ID = 6,
    TAG_OBJECT_DESCRIPTOR = 7,
    TAG_EXTERNAL = 8,
    TAG_REAL = 9,
    TAG_ENUMERATED = 10,
    TAG_EMBEDDED_PDV = 11,
    TAG_UTF8_STRING = 12,
    TAG_REALTIVE_OID = 13,
    TAG_SEQUENCE = 16,
    TAG_SET = 17,
    TAG_NUMERIC_STRING = 18,
    TAG_PRINTABLE_STRING = 19,
    TAG_TELETEX_STRING = 20,
    TAG_VIDEOTEX_STRING = 21,
    TAG_IA5_STRING = 22,
    TAG_UTC_TIME = 23,
    TAG_GENERALIZED_TIME = 24,
    TAG_GRAPHIC_STRING = 25,
    TAG_VISIBLE_STRING = 26,
    TAG_GENERAL_STRING = 27,
    TAG_UNIVERSAL_STRING = 28,
    TAG_CHARACTER_STRING = 29,
    TAG_BMP_STRING = 30
};

/* ASN.1 Parser object.  */
struct tag_info {
    int class;             /* Object class.  */
    unsigned long tag;     /* The tag of the object.  */
    unsigned long length;  /* Length of the values.  */
    int nhdr;              /* Length of the header (TL).  */
    unsigned int ndef:1;   /* The object has an indefinite length.  */
    unsigned int cons:1;   /* This is a constructed object.  */
};

/**
 * Read a file from stream FP into a newly allocated buffer and return that buffer.
 * The valid length of the buffer is stored at R_LENGTH. Returns NULL on failure.  If decode is set, the file is
 * assumed to be hex encoded and the decoded content is returned.
 * @param fp
 * @param decode
 * @param r_length
 * @return
 */
static void* read_file(FILE* fp, int decode, size_t* r_length)
{
    char* buffer;
    size_t buflen;
    size_t nread, bufsize = 0;

    *r_length = 0;
#define NCHUNK 8192
#ifdef HAVE_DOSISH_SYSTEM
    setmode (fileno(fp), O_BINARY);
#endif
    buffer = NULL;
    buflen = 0;
    do {
        bufsize += NCHUNK;
        if (!buffer) {
            buffer = gcry_xmalloc(bufsize);
        } else {
            buffer = gcry_xrealloc(buffer, bufsize);
        }

        nread = fread(buffer + buflen, 1, NCHUNK, fp);
        if (nread < NCHUNK && ferror(fp)) {
            gcry_free(buffer);
            return NULL;
        }
        buflen += nread;
    } while (nread == NCHUNK);
#undef NCHUNK
    if (decode) {
        const char* s;
        char* p;

        for (s = buffer, p = buffer, nread = 0; nread + 1 < buflen; s += 2, nread += 2) {
            if (!hexdigitp (s) || !hexdigitp (s + 1)) {
                gcry_free(buffer);
                return NULL;  /* Invalid hex digits. */
            }
            *(unsigned char*)p++ = xtoi_2 (s);
        }
        if (nread != buflen) {
            gcry_free(buffer);
            return NULL;  /* Odd number of hex digits. */
        }
        buflen = p - buffer;
    }

    *r_length = buflen;
    return buffer;
}

/**
 * Do in-place decoding of base-64 data of LENGTH in BUFFER.
 * @param buffer
 * @param length
 * @param newLength
 * @return the new length of the buffer.
 */
static int base64_decode(char* buffer, size_t length, size_t* newLength)
{
    static unsigned char const asctobin[128] =
            {
                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0xff, 0xff, 0xff, 0x3f,
                    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0xff, 0xff,
                    0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
                    0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12,
                    0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
                    0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,
                    0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
                    0x31, 0x32, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff
            };

    int err = 0;
    int idx = 0;
    unsigned char val = 0;
    int c = 0;
    char* d, * s;
    int lfseen = 1;

    *newLength = 0;

    /* Find BEGIN line.  */
    for (s = buffer; length; length--, s++) {
        if (lfseen && *s == '-' && length > 11 && !memcmp(s, "-----BEGIN ", 11)) {
            for (; length && *s != '\n'; length--, s++);
            break;
        }
        lfseen = (*s == '\n');
    }

    /* Decode until pad character or END line.  */
    for (d = buffer; length; length--, s++) {
        if (lfseen && *s == '-' && length > 9 && !memcmp(s, "-----END ", 9)) {
            break;
        }
        if ((lfseen = (*s == '\n')) || *s == ' ' || *s == '\r' || *s == '\t') {
            continue;
        }
        if (*s == '=') {
            /* Pad character: stop */
            if (idx == 1) {
                *d++ = val;
            }
            break;
        }

        if ((*s & 0x80) || (c = asctobin[*(unsigned char*)s]) == 0xff) {
            err = 999;
            //die ("invalid base64 character %02X at pos %d detected\n", *(unsigned char*)s, (int)(s-buffer));
            return err;
        }

        switch (idx) {
            case 0:
                val = c << 2;
                break;
            case 1:
                val |= (c >> 4) & 3;
                *d++ = val;
                val = (c << 4) & 0xf0;
                break;
            case 2:
                val |= (c >> 2) & 15;
                *d++ = val;
                val = (c << 6) & 0xc0;
                break;
            case 3:
                val |= c & 0x3f;
                *d++ = val;
                break;
        }
        idx = (idx + 1) % 4;
    }

    *newLength = d - buffer;
    return err;
}

/**
 * Parse the buffer at the address BUFFER which consists of the number of octets as stored at BUFLEN.
 * Return the tag and the length part from the TLV triplet. Update BUFFER and BUFLEN on success. Checks that the
 * encoded length does not exhaust the length of the provided buffer.
 * @param buffer
 * @param buflen
 * @param ti
 * @return
 */
static int parse_tag(unsigned char const** buffer, size_t* buflen, struct tag_info* ti)
{
    int c;
    unsigned long tag;
    const unsigned char* buf = *buffer;
    size_t length = *buflen;

    ti->length = 0;
    ti->ndef = 0;
    ti->nhdr = 0;

    /* Get the tag */
    if (!length) {
        return -1;
    } /* Premature EOF.  */
    c = *buf++;
    length--;
    ti->nhdr++;

    ti->class = (c & 0xc0) >> 6;
    ti->cons = !!(c & 0x20);
    tag = (c & 0x1f);

    if (tag == 0x1f) {
        tag = 0;
        do {
            tag <<= 7;
            if (!length) {
                return -1;
            } /* Premature EOF.  */
            c = *buf++;
            length--;
            ti->nhdr++;
            tag |= (c & 0x7f);
        } while ((c & 0x80));
    }
    ti->tag = tag;

    /* Get the length */
    if (!length) {
        return -1;
    } /* Premature EOF. */
    c = *buf++;
    length--;
    ti->nhdr++;

    if (!(c & 0x80))
        ti->length = c;
    else if (c == 0x80)
        ti->ndef = 1;
    else if (c == 0xff)
        return -1; /* Forbidden length value.  */
    else {
        unsigned long len = 0;
        int count = c & 0x7f;

        for (; count; count--) {
            len <<= 8;
            if (!length)
                return -1; /* Premature EOF.  */
            c = *buf++;
            length--;
            ti->nhdr++;
            len |= (c & 0xff);
        }
        ti->length = len;
    }

    if (ti->class == UNIVERSAL && !ti->tag)
        ti->length = 0;

    if (ti->length > length)
        return -1; /* Data larger than buffer.  */

    *buffer = buf;
    *buflen = length;
    return 0;
}

/**
 * Import a Private Key from a PEM file and return an S-Expression.
 * based on fipsdrv.c#read_private_key_file
 * @param keyFile
 * @param key_sexp
 * @return
 */
int importPEMPrivateKey(const char* keyFile, gcry_sexp_t* key_sexp)
{
    int err = 0;

    gcry_mpi_t keyparms[8];
    int n_keyparms = 8;
    gcry_sexp_t s_key;

    FILE* fp;
    if ((fp = fopen(keyFile, "rb")) == NULL) {
        THROW_ERROR(999, "Failed to open private key file");
    }

    size_t buflen;
    char* buffer = read_file(fp, 0, &buflen);
    fclose(fp);

    if (!buffer) {
        THROW_ERROR(999, "Failed to read private key file");
    }

    size_t oldBuflen = buflen;
    if ((err = base64_decode(buffer, oldBuflen, &buflen)) != 0) {
        gcry_free(buffer);
        THROW_ERROR(err, "Failed to decode private key buffer");
    }

// Parse the ASN.1 structure. 

    const unsigned char* der = (const unsigned char*)buffer;
    size_t derlen = buflen;

    struct tag_info ti;

    if (parse_tag(&der, &derlen, &ti) || ti.tag != TAG_SEQUENCE || ti.class || !ti.cons || ti.ndef) {
        gcry_free(buffer);
        THROW_ERROR(err, "Failed to parse tag from private key buffer");
    }

    if (parse_tag(&der, &derlen, &ti) || ti.tag != TAG_INTEGER || ti.class || ti.cons || ti.ndef) {
        gcry_free(buffer);
        THROW_ERROR(err, "Failed to parse tag from private key buffer");
    }

    if (ti.length != 1 || *der) {
        gcry_free(buffer);
        THROW_ERROR(err, "Incorrect tag length");
    }

    der += ti.length;
    derlen -= ti.length;

    int idx;
    for (idx = 0; idx < n_keyparms; idx++) {

        if (parse_tag(&der, &derlen, &ti) || ti.tag != TAG_INTEGER || ti.class || ti.cons || ti.ndef) {
            gcry_free(buffer);
            THROW_ERROR(999, "Failed to parse tag from private key buffer");
        }

        gcry_error_t gerr = gcry_mpi_scan(keyparms + idx, GCRYMPI_FMT_USG, der, ti.length, NULL);

        if (gerr) {
            gcry_free(buffer);
            THROW_ERROR(999, gcry_strerror(gerr));
        }

        der += ti.length;
        derlen -= ti.length;
    }

    if (idx != n_keyparms) {
        gcry_free(buffer);
        THROW_ERROR(999, "Incorrect number of key params in private key");
    }

    gcry_free(buffer);

// Convert from OpenSSL parameter ordering to the OpenPGP order.  
// First check that p < q; if not swap p and q and recompute u.   

    if (gcry_mpi_cmp(keyparms[3], keyparms[4]) > 0) {
        gcry_mpi_swap(keyparms[3], keyparms[4]);
        gcry_mpi_invm(keyparms[7], keyparms[3], keyparms[4]);
    }

// Build the S-expression. 

    gcry_error_t gerr = gcry_sexp_build(&s_key, NULL, "(private-key(rsa(n%m)(e%m)(d%m)(p%m)(q%m)(u%m)))",
                                        keyparms[0], keyparms[1], keyparms[2], keyparms[3], keyparms[4], keyparms[7]);

    if (gerr) {
        gcry_free(buffer);
        THROW_ERROR(999, gcry_strerror(gerr));
    }

    for (idx = 0; idx < n_keyparms; idx++) {
        gcry_mpi_release(keyparms[idx]);
    }

    *key_sexp = s_key;

    return err;
}

/**
 * Import a Public Key from a PEM file and return an S-Expression.
 * based on fipsdrv.c#read_public_key_file
 * @param keyFile
 * @param key_sexp
 * @return
 */
int importPEMPublicKey(char* keyFile, gcry_sexp_t* key_sexp)
{
    int err = 0;

    FILE* fp;
    if ((fp = fopen(keyFile, "rb")) == NULL) {
        THROW_ERROR(999, "Failed to open public key file");
    }

    size_t buflen;
    char* buffer = read_file(fp, 0, &buflen);
    fclose(fp);

    if (!buffer) {
        THROW_ERROR(999, "Failed to read public key file");
    }

    size_t oldBuflen = buflen;
    if ((err = base64_decode(buffer, oldBuflen, &buflen)) != 0) {
        gcry_free(buffer);
        THROW_ERROR(999, "Failed to decode public key");
    }

    // Parse the ASN.1 structure.

    const unsigned char* der = (const unsigned char*)buffer;
    size_t derlen = buflen;
    struct tag_info ti;

    if (parse_tag(&der, &derlen, &ti) || ti.tag != TAG_SEQUENCE || ti.class || !ti.cons || ti.ndef) {
        gcry_free(buffer);
        THROW_ERROR(err, "Failed to parse tag from public key buffer");
    }

    if (parse_tag(&der, &derlen, &ti) || ti.tag != TAG_SEQUENCE || ti.class || !ti.cons || ti.ndef) {
        gcry_free(buffer);
        THROW_ERROR(err, "Failed to parse tag from public key buffer");
    }

// We skip the description of the key parameters and assume it is RSA.  

    der += ti.length;
    derlen -= ti.length;

    if (parse_tag(&der, &derlen, &ti) || ti.tag != TAG_BIT_STRING || ti.class || ti.cons || ti.ndef) {
        gcry_free(buffer);
        THROW_ERROR(err, "Failed to parse tag from public key buffer");
    }

    if (ti.length < 1 || *der) {
        gcry_free(buffer);
        THROW_ERROR(err, "Incorrect tag length");
    }

    der += 1;
    derlen -= 1;

// Parse the BIT string. 

    if (parse_tag(&der, &derlen, &ti) || ti.tag != TAG_SEQUENCE || ti.class || !ti.cons || ti.ndef) {
        gcry_free(buffer);
        THROW_ERROR(err, "Failed to parse tag from public key buffer");
    }

    int idx;
    int n_keyparms = 2;
    gcry_mpi_t keyparms[2];

    for (idx = 0; idx < n_keyparms; idx++) {

        if (parse_tag(&der, &derlen, &ti) || ti.tag != TAG_INTEGER || ti.class || ti.cons || ti.ndef) {
            gcry_free(buffer);
            THROW_ERROR(err, "Failed to parse tag from public key buffer");
        }

        gcry_error_t gerr = gcry_mpi_scan(keyparms + idx, GCRYMPI_FMT_USG, der, ti.length, NULL);

        if (gerr) {
            gcry_free(buffer);
            THROW_ERROR(err, gcry_strerror(gerr));
        }
        der += ti.length;
        derlen -= ti.length;
    }

    if (idx != n_keyparms) {
        gcry_free(buffer);
        THROW_ERROR(err, "Incorrect number of params in public key");
    }

    gcry_free(buffer);

    // Build the S-expression.

    gcry_sexp_t s_key;

    gcry_error_t gerr = gcry_sexp_build(&s_key, NULL, "(public-key(rsa(n%m)(e%m)))", keyparms[0], keyparms[1]);
    if (gerr) {
        gcry_free(buffer);
        THROW_ERROR(err, gcry_strerror(gerr));
    }

    for (idx = 0; idx < n_keyparms; idx++) gcry_mpi_release(keyparms[idx]);

    *key_sexp = s_key;

    return err;
}

/**
 * Create a Multi-Precision Integer (MPI) token message (session ID)
 * @param tokenType
 * @param tokenByteLength
 * @param mpiToken
 * @return
 */
int createIdamMPIToken(unsigned short tokenType, unsigned short tokenByteLength, gcry_mpi_t* mpiToken)
{
    int err = 0;
    unsigned char* token = NULL;
    size_t tokenLength = 0;

    switch (tokenType) {
        // Standard Test Message
        case (NONCETEST): {
                const char* txt = "QWERTYqwerty0123456789";
                if (gcry_mpi_scan(mpiToken, GCRYMPI_FMT_USG, txt, strlen(txt), NULL) != 0) {
                    THROW_ERROR(999, "Unable to generate MPI Token");
                }
            }
            break;

        // Random bits
        case (NONCEWEAKRANDOM): {
                *mpiToken = gcry_mpi_new((unsigned int)tokenByteLength * 8);
                gcry_mpi_randomize(*mpiToken, (unsigned int)tokenByteLength * 8, GCRY_WEAK_RANDOM);
                if (*mpiToken == NULL) {
                    THROW_ERROR(999, "Unable to generate MPI Token");
                }
                gcry_mpi_aprint(GCRYMPI_FMT_HEX, &token, &tokenLength, *mpiToken);
                IDAM_LOGF(LOG_DEBUG, "MPI [%d] %s\n", tokenLength, token);
                free((void*)token);
            }
            break;

        // Random bits
        case (NONCESTRONGRANDOM): {
                *mpiToken = gcry_mpi_new((unsigned int)tokenByteLength * 8);
                gcry_mpi_randomize(*mpiToken, (unsigned int)tokenByteLength * 8, GCRY_STRONG_RANDOM);
                if (*mpiToken == NULL) {
                    THROW_ERROR(999, "Unable to generate MPI Token");
                }
                gcry_mpi_aprint(GCRYMPI_FMT_HEX, &token, &tokenLength, *mpiToken);
                IDAM_LOGF(LOG_DEBUG, "MPI [%d] %s\n", tokenLength, token);
                free((void*)token);
            }
            break;

        // Random String
        case (NONCESTRINGRANDOM): {

            // Get the current Process ID
            unsigned int pid = (unsigned int)getpid();

            // Get the current time and convert to a string
            unsigned long long t = (unsigned long long)time(NULL);
            char timeList[256];   // Overestimate of the maximum possible size of a long long integer
            sprintf(timeList, "%llu", t);
            size_t timeLength = strlen(timeList);

            // Seed the (poor) system random number generator with the process ID and create a random string
            unsigned char* randList = (unsigned char*)malloc(tokenByteLength * sizeof(unsigned char));
            srand(pid); // Seed the random number generator
            int i;
            for (i = 0; i < tokenByteLength; i++) {
                // quasi-random integers in the range 1-255
                randList[i] = (unsigned char)(1 + (int)(255.0 * (rand() / (RAND_MAX + 1.0))));
            }

            // Create an MPI from both the time and the quasi-random list
            gcry_mpi_t timeData;
            if (gcry_mpi_scan(&timeData, GCRYMPI_FMT_USG, timeList, timeLength, NULL) != 0) {
                free((void*)randList);
                THROW_ERROR(999, "Unable to generate MPI Token");
            }

            gcry_mpi_t randData;
            if (gcry_mpi_scan(&randData, GCRYMPI_FMT_USG, randList, tokenByteLength, NULL) != 0) {
                gcry_mpi_release(timeData);
                free((void*)randList);
                THROW_ERROR(999, "Unable to generate MPI Token");
            }

            free((void*)randList);

            // Multiply to generate a token
            *mpiToken = gcry_mpi_new(0);
            gcry_mpi_mul(*mpiToken, timeData, randData);

            if (*mpiToken == NULL) {
                gcry_mpi_release(timeData);
                gcry_mpi_release(randData);
                THROW_ERROR(999, "Unable to generate MPI Token");
            }

            gcry_mpi_release(timeData);
            gcry_mpi_release(randData);

            IDAM_LOGF(LOG_DEBUG, "createMPIToken:pid  = %u\n", pid);
            IDAM_LOGF(LOG_DEBUG, "               time = %u\n", t);
            gcry_mpi_aprint(GCRYMPI_FMT_HEX, &token, &tokenLength, *mpiToken);
            IDAM_LOGF(LOG_DEBUG, "MPI [%d] %s\n", tokenLength, token);
            free((void*)token);

            return 0;
        }

        default:
            THROW_ERROR(999, "Unknown token type");
    }

    return err;
}

/**
 * Given an S-expression ENCR_DATA of the form:
 *      (enc-val
 *       (rsa
 *        (a a-value)))
 * as returned by gcry_pk_decrypt, return the the A-VALUE. On error, return NULL.
 * @param encr_data
 * @return
 */
gcry_mpi_t extract_a_from_sexp(gcry_sexp_t encr_data)
{

    gcry_sexp_t l1, l2, l3;
    gcry_mpi_t a_value;

    l1 = gcry_sexp_find_token(encr_data, "enc-val", 0);
    if (!l1) {
        return NULL;
    }
    l2 = gcry_sexp_find_token(l1, "rsa", 0);
    gcry_sexp_release(l1);
    if (!l2) {
        return NULL;
    }
    l3 = gcry_sexp_find_token(l2, "a", 0);
    gcry_sexp_release(l2);
    if (!l3) {
        return NULL;
    }
    a_value = gcry_sexp_nth_mpi(l3, 1, 0);
    gcry_sexp_release(l3);

    return a_value;
}

static int generateToken(gcry_mpi_t* mpi_token, unsigned short tokenType, unsigned short tokenByteLength)
{
    int err = 0;

    if (*mpi_token != NULL) {
        gcry_mpi_release(*mpi_token);
        *mpi_token = NULL;
    }

    unsigned char* token = NULL;
    size_t tokenLength = 0;

    err = createIdamMPIToken(tokenType, tokenByteLength, mpi_token);

    if (err != 0 || *mpi_token == NULL) {
        if (*mpi_token != NULL) {
            gcry_mpi_release(*mpi_token);
            *mpi_token = NULL;
        }
        THROW_ERROR(err, "Error Generating Token");
    }

    gcry_mpi_aprint(GCRYMPI_FMT_HEX, &token, &tokenLength, *mpi_token);
    IDAM_LOGF(LOG_DEBUG, "Token MPI [%d] %s\n", tokenLength, token);
    free((void*)token);

    return err;
}

static int encryptToken(gcry_mpi_t* mpi_token, unsigned short encryptionMethod, gcry_sexp_t key, unsigned char** ciphertext, size_t* ciphertext_len)
{
    int err = 0;

    gcry_sexp_t mpiTokenSexp = NULL;    // Token as a S-Expression

    gpg_error_t gerr;

    if ((gerr = gcry_sexp_build(&mpiTokenSexp, NULL, "(data (flags raw) (value %m))", *mpi_token)) != 0) {
        gcry_mpi_release(*mpi_token);
        *mpi_token = NULL;
        if (mpiTokenSexp != NULL) {
            gcry_sexp_release(mpiTokenSexp);
            mpiTokenSexp = NULL;
        }
        addIdamError(&idamerrorstack, CODEERRORTYPE, __func__, 999, "Error Generating Token S-Exp");
        THROW_ERROR(999, gpg_strerror(gerr));
    }

    switch (encryptionMethod) {
        case (ASYMMETRICKEY): {
            gcry_sexp_t encr = NULL; // Encrypted token

            // Encrypt
            if ((gerr = gcry_pk_encrypt(&encr, mpiTokenSexp, key)) != 0) {
                if (mpiTokenSexp != NULL) gcry_sexp_release(mpiTokenSexp);
                addIdamError(&idamerrorstack, CODEERRORTYPE, __func__, 999, "Encryption Error");
                THROW_ERROR(999, gpg_strerror(gerr));
            }

            if (mpiTokenSexp != NULL) gcry_sexp_release(mpiTokenSexp);

            gcry_mpi_t encrypted_token = NULL; // MPI in encrypted form

            // Extract the ciphertext from the S-expression
            if ((encrypted_token = extract_a_from_sexp(encr)) == NULL) {
                if (encr != NULL) gcry_sexp_release(encr);
                THROW_ERROR(999, "Poor Encryption");
            }

            // Check the ciphertext does not match the plaintext
            if (!gcry_mpi_cmp(*mpi_token, encrypted_token)) {
                if (encrypted_token != NULL) gcry_mpi_release(encrypted_token);
                THROW_ERROR(999, "Poor Encryption");
            }

            // Return the ciphertext
            *ciphertext_len = gcry_sexp_sprint(encr, GCRYSEXP_FMT_DEFAULT, NULL, 0);

            if (*ciphertext_len == 0) {
                if (encr != NULL) gcry_sexp_release(encr);
                if (encrypted_token != NULL) gcry_mpi_release(encrypted_token);
                *ciphertext = NULL;
                THROW_ERROR(999, "Ciphertext extraction error");
            }

            *ciphertext = (unsigned char*)malloc(*ciphertext_len * sizeof(unsigned char));
            gcry_sexp_sprint(encr, GCRYSEXP_FMT_DEFAULT, *ciphertext, *ciphertext_len);

            if (*ciphertext == NULL) {
                if (encr != NULL) gcry_sexp_release(encr);
                if (encrypted_token != NULL) gcry_mpi_release(encrypted_token);
                THROW_ERROR(999, "Ciphertext extraction error");
            }

            unsigned char* token = NULL;
            size_t tokenLength = 0;

            gcry_mpi_aprint(GCRYMPI_FMT_HEX, &token, &tokenLength, encrypted_token);
            IDAM_LOGF(LOG_DEBUG, "Encrypted SEXP [%d] %s\n", tokenLength, token);
            free((void*)token);

            if (encrypted_token != NULL) gcry_mpi_release(encrypted_token);

            break;
        }

        default:
            THROW_ERROR(999, "Unknown encryption method");
    }

    return err;
}

static int decryptToken(gcry_mpi_t* mpi_token, gcry_sexp_t key, unsigned char** ciphertext, size_t* ciphertext_len)
{
    int err = 0;

    // Create S-Expression from the passed ciphertext and decrypt

    gpg_error_t gerr = 0;
    gcry_sexp_t encr = NULL; // Encrypted token
    gcry_sexp_t decr = NULL; // Decrypted token

    if ((gerr = gcry_sexp_create(&encr, (void*)*ciphertext, *ciphertext_len, 1, NULL)) != 0) {
        addIdamError(&idamerrorstack, CODEERRORTYPE, __func__, 999, "Error Generating Token S-Exp");
        THROW_ERROR(999, (char*)gpg_strerror(gerr));
    }

    if ((gerr = gcry_pk_decrypt(&decr, encr, key)) != 0) {
        gcry_sexp_release(encr);
        addIdamError(&idamerrorstack, CODEERRORTYPE, __func__, 999, "Decryption Error");
        THROW_ERROR(999, (char*)gpg_strerror(gerr));
    }

    gcry_sexp_release(encr);

    // Extract the decrypted data from the S-expression.
    gcry_sexp_t tmplist = gcry_sexp_find_token(decr, "value", 0);

    gcry_mpi_t plaintext = NULL;

    if (tmplist) {
        plaintext = gcry_sexp_nth_mpi(tmplist, 1, GCRYMPI_FMT_USG);
        gcry_sexp_release(tmplist);
    } else {
        plaintext = gcry_sexp_nth_mpi(decr, 0, GCRYMPI_FMT_USG);
    }

    gcry_sexp_release(decr);

    if (!plaintext) {
        THROW_ERROR(999, "S-Exp contains no plaintext!");
    }

    unsigned char* token = NULL;
    size_t tokenLength = 0;

    gcry_mpi_aprint(GCRYMPI_FMT_HEX, &token, &tokenLength, plaintext);
    IDAM_LOGF(LOG_DEBUG, "Token MPI [%d] %s\n", tokenLength, token);
    free((void*)token);

    // Return the Client MPI token
    *mpi_token = plaintext;

    return err;
}

int udaAuthentication(unsigned short authenticationStep, unsigned short encryptionMethod,
                      unsigned short tokenType, unsigned short tokenByteLength,
                      gcry_sexp_t publickey, gcry_sexp_t privatekey,
                      gcry_mpi_t* client_mpiToken, gcry_mpi_t* server_mpiToken,
                      unsigned char** client_ciphertext, size_t* client_ciphertextLength,
                      unsigned char** server_ciphertext, size_t* server_ciphertextLength)
{

    int err = 0;

    // Initialise the library

    static BOOLEAN initialised = FALSE;

    if (!initialised) {
        // Check version of runtime gcrypt library.
        if (!gcry_check_version(GCRYPT_VERSION)) {
            THROW_ERROR(999, "Library version incorrect!");
        }

        // Disable secure memory.
        gcry_control(GCRYCTL_DISABLE_SECMEM, 0);

        // Tell Libgcrypt that initialization has completed.
        gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);

        initialised = TRUE;
    }

    //--------------------------------------------------------------------------------------------------------------------
    // Authentication Steps

    static gcry_mpi_t mpiTokenA = NULL;    // Token passed from the client to the server (preserve for comparison)
    static gcry_mpi_t mpiTokenB = NULL;    // Token passed from the server to the client (preserve for comparison)

    IDAM_LOGF(LOG_DEBUG, "Step %d\n", authenticationStep);

    switch (authenticationStep) {
        case CLIENT_ISSUE_TOKEN: {        // Client issues a token (A), encrypts with the server's public key (EASP), passes to server
            err = generateToken(&mpiTokenA, tokenType, tokenByteLength);
            if (err != 0) {
                break;
            }
            err = encryptToken(&mpiTokenA, encryptionMethod, publickey, client_ciphertext, client_ciphertextLength);
            break;
        }

        case SERVER_DECRYPT_CLIENT_TOKEN: {        // Server decrypts the passed cipher (EASP) with the server's private key (A)
            err = decryptToken(client_mpiToken, privatekey, client_ciphertext, client_ciphertextLength);
            break;
        }

        case SERVER_ENCRYPT_CLIENT_TOKEN: {        // Server encrypts the client token (A) with the client's public key (EACP)
            err = encryptToken(client_mpiToken, encryptionMethod, publickey, client_ciphertext, client_ciphertextLength);
            break;
        }

        case SERVER_ISSUE_TOKEN: {        // Server issues a new token (B) encrypted with the client's public key (EBCP), passes both to client
            err = generateToken(&mpiTokenB, tokenType, tokenByteLength);
            if (err != 0) {
                break;
            }
            err = encryptToken(&mpiTokenB, encryptionMethod, publickey, server_ciphertext, server_ciphertextLength);
            break;
        }

        case CLIENT_DECRYPT_SERVER_TOKEN: {        // Client decrypts the passed ciphers (EACP, EBCP) with the client's private key (A, B)
            gcry_mpi_t received_token = NULL;
            err = decryptToken(&received_token, privatekey, client_ciphertext, client_ciphertextLength);

            // Check that the decrypted token matches the original token.
            if (gcry_mpi_cmp(mpiTokenA, received_token)) {
                gcry_mpi_release(received_token);
                THROW_ERROR(999, "Server Authentication Failed!");
            }

            gcry_mpi_release(received_token);

            // Server has been authenticated so delete the original token A - no longer required.
            gcry_mpi_release(mpiTokenA);
            mpiTokenA = NULL;

            err = decryptToken(server_mpiToken, privatekey, server_ciphertext, server_ciphertextLength);
            break;
        }

        case CLIENT_ENCRYPT_SERVER_TOKEN: {        // Client encrypts passed token (B) with the server's public key (EBSP), passes to server
            err = encryptToken(server_mpiToken, encryptionMethod, publickey, server_ciphertext, server_ciphertextLength);
            break;
        }

        case SERVER_VERIFY_TOKEN: {        // Server decrypts the passed cipher (EBSP) with the server's private key (B)
            gcry_mpi_t received_token = NULL;
            err = decryptToken(&received_token, privatekey, server_ciphertext, server_ciphertextLength);

            // Check that the decrypted token matches the original token.
            if (gcry_mpi_cmp(mpiTokenB, received_token)) {
                gcry_mpi_release(received_token);
                THROW_ERROR(999, "Client Authentication Failed!");
            }

            gcry_mpi_release(received_token);

            // Client has been authenticated so delete the original token B - no longer required.
            gcry_mpi_release(mpiTokenB);
            mpiTokenB = NULL;
            break;
        }

        default: {
            THROW_ERROR(999, "Uknown User Authentication Step");
        }

    }

    return err;
}

